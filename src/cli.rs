use crate::{
    blockchain::Blockchain,
    transaction::Transaction,
    wallet::Wallet,
};
use anyhow::{Error, Result};
use std::{
    collections::HashMap,
    io::{self, BufRead, Write},
    sync::{Arc, Mutex},
    time::{SystemTime, UNIX_EPOCH},
};

type BlockchainRef = Arc<Mutex<Blockchain>>;

/// Structure repr√©sentant l'interface en ligne de commande
pub struct CLI {
    blockchain: BlockchainRef,
    wallets: HashMap<String, Wallet>,
    pending_transactions: Vec<Transaction>,
}

impl CLI {
    /// Cr√©e une nouvelle instance de l'interface CLI
    pub fn new(blockchain: BlockchainRef) -> Result<Self> {
        let mut wallets = HashMap::new();
        
        // Cr√©er un portefeuille par d√©faut
        let wallet = Wallet::new()?;
        let address = wallet.get_address()?;
        
        println!("Portefeuille par d√©faut cr√©√©: {}", address);
        wallets.insert(address, wallet);
        
        Ok(Self { 
            blockchain, 
            wallets, 
            pending_transactions: Vec::with_capacity(10),
        })
    }
    
    /// D√©marre la boucle principale d'interface
    pub fn run(&mut self) -> Result<()> {
        println!("Interface NeuralChain v2 d√©marr√©e");
        
        let stdin = io::stdin();
        let mut stdin_lock = stdin.lock();
        let mut input = String::with_capacity(64);
        
        loop {
            self.print_menu();
            
            print!("> ");
            io::stdout().flush()?;
            input.clear();
            stdin_lock.read_line(&mut input)?;
            
            match input.trim() {
                "1" => self.create_wallet()?,
                "2" => self.list_wallets(),
                "3" => self.send_transaction(&mut stdin_lock)?,
                "4" => self.mine_block()?,
                "5" => self.show_blockchain(),
                "6" => self.check_balance(&mut stdin_lock)?,
                "7" => self.show_pending_transactions(),
                "0" => break,
                _ => println!("‚ùå Option non valide, veuillez r√©essayer"),
            }
        }
        
        println!("Interface NeuralChain v2 arr√™t√©e");
        Ok(())
    }
    
    /// Affiche le menu principal
    #[inline]
    fn print_menu(&self) {
        println!("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MENU NEURALCHAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        println!("‚îÇ 1. Cr√©er un nouveau portefeuille    ‚îÇ");
        println!("‚îÇ 2. Lister les portefeuilles         ‚îÇ");
        println!("‚îÇ 3. Envoyer une transaction          ‚îÇ");
        println!("‚îÇ 4. Miner un bloc                    ‚îÇ");
        println!("‚îÇ 5. Afficher la blockchain           ‚îÇ");
        println!("‚îÇ 6. V√©rifier un solde                ‚îÇ");
        println!("‚îÇ 7. Transactions en attente ({:2})     ‚îÇ", self.pending_transactions.len());
        println!("‚îÇ 0. Quitter                          ‚îÇ");
        println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
    }
    
    /// Cr√©e un nouveau portefeuille et l'ajoute √† la liste
    fn create_wallet(&mut self) -> Result<()> {
        let wallet = Wallet::new()?;
        let address = wallet.get_address()?;
        
        println!("‚úÖ Nouveau portefeuille cr√©√©: {}", address);
        self.wallets.insert(address, wallet);
        
        Ok(())
    }
    
    /// Affiche la liste des portefeuilles disponibles
    fn list_wallets(&self) {
        if self.wallets.is_empty() {
            println!("Aucun portefeuille disponible");
            return;
        }
        
        println!("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PORTEFEUILLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        for (i, (address, _)) in self.wallets.iter().enumerate() {
            println!("‚îÇ {}. {} ‚îÇ", i+1, address);
        }
        println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
    }
    
    /// Lit un index de portefeuille depuis l'entr√©e standard
    fn read_wallet_index(&self, stdin: &mut impl BufRead) -> Result<usize> {
        if self.wallets.is_empty() {
            return Err(Error::msg("Aucun portefeuille disponible"));
        }
        
        let addresses: Vec<_> = self.wallets.keys().cloned().collect();
        
        let mut input = String::with_capacity(16);
        print!("> ");
        io::stdout().flush()?;
        input.clear();
        stdin.read_line(&mut input)?;
        
        let index = input.trim().parse::<usize>()
            .map_err(|_| Error::msg("Entr√©e non valide"))?;
            
        if index < 1 || index > addresses.len() {
            return Err(Error::msg("Index de portefeuille non valide"));
        }
        
        Ok(index - 1)
    }
    
    /// Envoie une transaction entre deux adresses
    fn send_transaction(&mut self, stdin: &mut impl BufRead) -> Result<()> {
        self.list_wallets();
        
        if self.wallets.is_empty() {
            println!("‚ùå Aucun portefeuille disponible pour effectuer des transactions");
            return Ok(());
        }
        
        // S√©lectionner le portefeuille source
        println!("Choisissez le portefeuille source (par num√©ro):");
        let index = match self.read_wallet_index(stdin) {
            Ok(idx) => idx,
            Err(e) => {
                println!("‚ùå {}", e);
                return Ok(());
            }
        };
        
        let addresses: Vec<String> = self.wallets.keys().cloned().collect();
        let from_address = addresses[index].clone();
        
        // Demander l'adresse destinataire
        println!("Entrez l'adresse du destinataire:");
        let mut to_address = String::with_capacity(64);
        print!("> ");
        io::stdout().flush()?;
        stdin.read_line(&mut to_address)?;
        to_address = to_address.trim().to_string();
        
        // V√©rifier si l'adresse est valide (doit avoir une certaine longueur minimale)
        if to_address.len() < 10 {
            println!("‚ùå Adresse destinataire non valide");
            return Ok(());
        }
        
        // Demander le montant
        println!("Entrez le montant √† envoyer:");
        let mut amount_str = String::with_capacity(32);
        print!("> ");
        io::stdout().flush()?;
        stdin.read_line(&mut amount_str)?;
        
        let amount: u64 = match amount_str.trim().parse() {
            Ok(num) if num > 0 => num,
            _ => {
                println!("‚ùå Montant non valide");
                return Ok(());
            }
        };
        
        // Cr√©ation de la transaction
        println!("üí∏ Cr√©ation d'une transaction:");
        println!("  De: {}", from_address);
        println!("  √Ä: {}", to_address);
        println!("  Montant: {}", amount);
        
        // Dans une impl√©mentation r√©elle, nous devrions v√©rifier le solde ici
        let wallet = self.wallets.get(&from_address).unwrap();
        
        // Cr√©ation d'une transaction valide (adapt√©e √† votre impl√©mentation)
        let mut transaction = Transaction::new(
            from_address,
            to_address,
            amount,
            1, // frais de transaction
            Some(wallet),
        )?;
        
        // Ajouter aux transactions en attente
        self.pending_transactions.push(transaction);
        println!("‚úÖ Transaction cr√©√©e et ajout√©e au pool de transactions en attente");
        
        Ok(())
    }
    
    /// Mine un bloc avec les transactions disponibles
    fn mine_block(&mut self) -> Result<()> {
        println!("‚õèÔ∏è Minage d'un nouveau bloc...");
        
        if self.pending_transactions.is_empty() {
            println!("‚ùå Aucune transaction en attente √† miner");
            return Ok(());
        }
        
        // Prendre les transactions en attente
        let transactions = std::mem::take(&mut self.pending_transactions);
        
        // Obtenir le timestamp actuel
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0);
        
        // Miner le bloc
        let start_time = std::time::Instant::now();
        
        // Utiliser try_lock pour √©viter les deadlocks potentiels
        let mut bc = match self.blockchain.try_lock() {
            Ok(bc) => bc,
            Err(_) => return Err(Error::msg("Blockchain verrouill√©e par un autre processus")),
        };
        
        // Ajouter le bloc √† la blockchain
        bc.add_block(transactions)?;
        
        let elapsed = start_time.elapsed();
        println!("‚úÖ Bloc min√© en {:.2?}!", elapsed);
        
        Ok(())
    }
    
    /// Affiche l'√©tat actuel de la blockchain
    fn show_blockchain(&self) {
        // Utiliser try_lock pour √©viter les deadlocks potentiels
        let bc = match self.blockchain.try_lock() {
            Ok(bc) => bc,
            Err(_) => {
                println!("‚ùå Blockchain verrouill√©e par un autre processus");
                return;
            }
        };
        
        println!("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BLOCKCHAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        
        // Obtenir le nombre de blocs
        let blocks_count = bc.get_height();
        
        if blocks_count == 0 {
            println!("‚îÇ La blockchain est vide         ‚îÇ");
        } else {
            // Afficher les d√©tails des derniers blocs (max 5)
            let max_blocks = 5;
            let start_idx = if blocks_count > max_blocks { blocks_count - max_blocks } else { 0 };
            
            for i in start_idx..blocks_count {
                if let Ok(Some(block)) = bc.get_block_at_height(i) {
                    println!("‚îÇ Bloc #{:<3}                    ‚îÇ", i);
                    println!("‚îÇ   Hash: {:.8}...        ‚îÇ", hex::encode(&block.hash));
                    println!("‚îÇ   Hash prec.: {:.8}...    ‚îÇ", hex::encode(&block.prev_hash));
                    println!("‚îÇ   Nonce: {:<10}           ‚îÇ", block.nonce);
                    println!("‚îÇ   Difficult√©: {:<3}           ‚îÇ", block.difficulty);
                    println!("‚îÇ   Transactions: {:<3}         ‚îÇ", block.transactions.len());
                    
                    if i < blocks_count - 1 {
                        println!("‚îÇ                              ‚îÇ");
                    }
                }
            }
            
            if blocks_count > max_blocks {
                println!("‚îÇ (+ {} blocs pr√©c√©dents)       ‚îÇ", blocks_count - max_blocks);
            }
        }
        
        println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
    }
    
    /// Affiche les transactions en attente
    fn show_pending_transactions(&self) {
        println!("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TRANSACTIONS EN ATTENTE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        
        if self.pending_transactions.is_empty() {
            println!("‚îÇ Aucune transaction en attente            ‚îÇ");
        } else {
            for (i, tx) in self.pending_transactions.iter().enumerate() {
                println!("‚îÇ Transaction #{:<3}                      ‚îÇ", i+1);
                println!("‚îÇ   De: {:.15}...        ‚îÇ", tx.sender);
                println!("‚îÇ   √Ä: {:.15}...        ‚îÇ", tx.recipient);
                println!("‚îÇ   Montant: {:<10}                  ‚îÇ", tx.amount);
                println!("‚îÇ   Frais: {:<10}                    ‚îÇ", tx.fee);
                
                if i < self.pending_transactions.len() - 1 {
                    println!("‚îÇ                                       ‚îÇ");
                }
            }
        }
        
        println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
    }
    
    /// V√©rifie le solde d'une adresse
    fn check_balance(&self, stdin: &mut impl BufRead) -> Result<()> {
        self.list_wallets();
        
        if self.wallets.is_empty() {
            println!("‚ùå Aucun portefeuille disponible");
            return Ok(());
        }
        
        println!("Choisissez le portefeuille (par num√©ro):");
        let index = match self.read_wallet_index(stdin) {
            Ok(idx) => idx,
            Err(e) => {
                println!("‚ùå {}", e);
                return Ok(());
            }
        };
        
        let addresses: Vec<String> = self.wallets.keys().cloned().collect();
        let address = &addresses[index];
        
        // Simuler le calcul du solde pour l'instant
        let balance = 100u64;
        
        // Afficher le solde
        println!("üí∞ Le solde de l'adresse {} est: {} NeuralCoins", address, balance);
        
        Ok(())
    }
    
    /// Sauvegarde les portefeuilles sur disque
    pub fn save_wallets(&self) -> Result<()> {
        // Dans une impl√©mentation r√©elle, nous sauvegarderions les portefeuilles ici
        println!("üìù Sauvegarde des portefeuilles...");
        
        for (address, _) in &self.wallets {
            println!("  - Portefeuille {}: sauvegard√©", address);
        }
        
        println!("‚úÖ Portefeuilles sauvegard√©s avec succ√®s");
        Ok(())
    }
}

impl Drop for CLI {
    fn drop(&mut self) {
        // Tenter de sauvegarder les portefeuilles √† la fermeture
        if let Err(e) = self.save_wallets() {
            eprintln!("‚ùå Erreur lors de la sauvegarde des portefeuilles: {}", e);
        }
    }
}
